/**
 * Vulnerability Detector
 * Detects common cheating patterns in code verification
 */

class VulnerabilityDetector {
  
  /**
   * Analyze code for potential vulnerabilities
   * @param {Object} astFeatures - AST features from astParser
   * @param {string} code - Source code
   * @param {string} language - Programming language
   * @returns {Object} Vulnerability analysis
   */
  analyzeCode(astFeatures, code, language) {
    const vulnerabilities = {
      suspicion_level: 'NONE', // NONE, LOW, MEDIUM, HIGH, CRITICAL
      flags: [],
      details: {},
      score: 0 // 0-100, higher = more suspicious
    };

    // Detect hardcoded return values
    const hardcodedReturns = this.detectHardcodedReturns(astFeatures, code, language);
    if (hardcodedReturns.detected) {
      vulnerabilities.flags.push('HARDCODED_RETURN');
      vulnerabilities.details.hardcoded_returns = hardcodedReturns;
      vulnerabilities.score += 40;
    }

    // Detect unused parameters
    const unusedParams = this.detectUnusedParameters(astFeatures, code, language);
    if (unusedParams.detected) {
      vulnerabilities.flags.push('UNUSED_PARAMETERS');
      vulnerabilities.details.unused_parameters = unusedParams;
      vulnerabilities.score += 30;
    }

    // Detect suspiciously simple implementation
    const tooSimple = this.detectSuspiciouslySimple(astFeatures);
    if (tooSimple.detected) {
      vulnerabilities.flags.push('SUSPICIOUSLY_SIMPLE');
      vulnerabilities.details.suspiciously_simple = tooSimple;
      vulnerabilities.score += 20;
    }

    // Set overall suspicion level
    if (vulnerabilities.score >= 70) {
      vulnerabilities.suspicion_level = 'CRITICAL';
    } else if (vulnerabilities.score >= 50) {
      vulnerabilities.suspicion_level = 'HIGH';
    } else if (vulnerabilities.score >= 30) {
      vulnerabilities.suspicion_level = 'MEDIUM';
    } else if (vulnerabilities.score > 0) {
      vulnerabilities.suspicion_level = 'LOW';
    }

    return vulnerabilities;
  }

  /**
   * Detect hardcoded return values (constants without computation)
   */
  detectHardcodedReturns(astFeatures, code, language) {
    const result = {
      detected: false,
      constants_found: [],
      reason: null
    };

    // Simple heuristic: if there are return statements but no arithmetic operations
    // and no parameter usage, likely hardcoded
    const hasReturns = code.includes('return');
    const hasArithmetic = astFeatures.operations?.arithmetic > 0;
    const hasComparison = astFeatures.operations?.comparison > 0;
    const hasLogical = astFeatures.operations?.logical > 0;
    const hasOperations = hasArithmetic || hasComparison || hasLogical;

    if (hasReturns && !hasOperations) {
      // Check if return statement contains a literal
      const returnMatches = code.match(/return\s+([^;]+);/g);
      if (returnMatches) {
        for (const match of returnMatches) {
          // Check for numeric literals
          if (/return\s+[-]?\d+/.test(match)) {
            const numMatch = match.match(/return\s+([-]?\d+)/);
            if (numMatch) {
              result.constants_found.push(numMatch[1]);
            }
          }
        }
      }

      if (result.constants_found.length > 0) {
        result.detected = true;
        result.reason = `Function returns constant value(s): ${result.constants_found.join(', ')} without performing any operations`;
      }
    }

    return result;
  }

  /**
   * Detect unused function parameters
   */
  detectUnusedParameters(astFeatures, code, language) {
    const result = {
      detected: false,
      unused_params: [],
      reason: null
    };

    // Extract function parameters and check if they appear in the function body
    const paramPattern = this.getParameterPattern(language);
    if (!paramPattern) return result;

    const funcMatch = code.match(paramPattern);
    if (funcMatch && funcMatch.length > 1) {
      const paramsString = funcMatch[1];
      
      // Extract individual parameter names
      const params = this.extractParameterNames(paramsString, language);
      
      // Check if each parameter is used in the function body
      for (const param of params) {
        // Simple check: does the parameter name appear after its declaration?
        const paramRegex = new RegExp(`\\b${param}\\b`, 'g');
        const matches = code.match(paramRegex);
        
        // Should appear at least twice (declaration + usage)
        if (!matches || matches.length < 2) {
          result.unused_params.push(param);
        }
      }

      if (result.unused_params.length > 0) {
        result.detected = true;
        result.reason = `Function parameters declared but never used: ${result.unused_params.join(', ')}`;
      }
    }

    return result;
  }

  /**
   * Detect suspiciously simple implementations
   */
  detectSuspiciouslySimple(astFeatures) {
    const result = {
      detected: false,
      reason: null,
      metrics: {
        total_nodes: astFeatures.totalNodes,
        operations: astFeatures.operations?.arithmetic || 0,
        control_flow: Object.values(astFeatures.controlFlow || {}).reduce((a, b) => a + b, 0)
      }
    };

    // If code has function but very few operations
    if (astFeatures.functions && astFeatures.functions.length > 0) {
      const totalOperations = result.metrics.operations + result.metrics.control_flow;
      
      if (totalOperations === 0 && astFeatures.totalNodes < 30) {
        result.detected = true;
        result.reason = 'Function has no operations or control flow - may be hardcoded';
      }
    }

    return result;
  }

  /**
   * Get regex pattern for extracting function parameters by language
   */
  getParameterPattern(language) {
    const patterns = {
      'c': /\w+\s+\w+\s*\(([^)]*)\)/,
      'cpp': /\w+\s+\w+\s*\(([^)]*)\)/,
      'c++': /\w+\s+\w+\s*\(([^)]*)\)/,
      'java': /\w+\s+\w+\s*\(([^)]*)\)/,
      'javascript': /function\s+\w+\s*\(([^)]*)\)|const\s+\w+\s*=\s*\(([^)]*)\)\s*=>/,
      'js': /function\s+\w+\s*\(([^)]*)\)|const\s+\w+\s*=\s*\(([^)]*)\)\s*=>/,
      'python': /def\s+\w+\s*\(([^)]*)\)/
    };
    return patterns[language.toLowerCase()];
  }

  /**
   * Extract parameter names from parameter string
   */
  extractParameterNames(paramsString, language) {
    const params = [];
    
    if (!paramsString || paramsString.trim() === '') {
      return params;
    }

    // Split by comma and extract names
    const parts = paramsString.split(',');
    
    for (const part of parts) {
      const trimmed = part.trim();
      if (!trimmed) continue;

      // For C/C++/Java: "int x" -> extract "x"
      if (['c', 'cpp', 'c++', 'java'].includes(language.toLowerCase())) {
        const words = trimmed.split(/\s+/);
        if (words.length > 0) {
          const paramName = words[words.length - 1].replace(/[*&]/g, '');
          params.push(paramName);
        }
      } else {
        // For Python/JavaScript: just the name
        params.push(trimmed.split('=')[0].trim());
      }
    }

    return params;
  }

  /**
   * Generate warning message based on vulnerabilities
   */
  generateWarning(vulnerabilities) {
    if (vulnerabilities.suspicion_level === 'NONE') {
      return null;
    }

    const messages = [];

    if (vulnerabilities.flags.includes('HARDCODED_RETURN')) {
      messages.push('⚠️  HARDCODED OUTPUT: Function returns constant without computation');
    }

    if (vulnerabilities.flags.includes('UNUSED_PARAMETERS')) {
      messages.push('⚠️  UNUSED PARAMETERS: Function parameters are not used in computation');
    }

    if (vulnerabilities.flags.includes('SUSPICIOUSLY_SIMPLE')) {
      messages.push('⚠️  SUSPICIOUS: Code appears too simple - may not implement actual algorithm');
    }

    return {
      level: vulnerabilities.suspicion_level,
      message: messages.join(' | '),
      recommendation: 'Manual review recommended. Code may be hardcoded for specific test input(s).',
      score: vulnerabilities.score
    };
  }
}

module.exports = { VulnerabilityDetector };
